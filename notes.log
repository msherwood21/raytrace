Section 2.3
-----------
- println! goes to stdio (duh). eprintln! goes to stderr.
- There is an [e]print! macro that is [e]println! without the newline at the end

Section 3.1, 3.2, 3.3
---------------------
- How do we include files? Reading chapter 7 of the rust book to understand...
  - I think I need to define a small module structure to know what I can call
    - Quick detour to read chapter 17 and 17.1. Objects look different here!
    - Make sure everything is `pub` if you want to call it
  - Ok, so at the top of a file put `mod <name of module>`. Rust will look in
    `<name of module>/mod.rs`. I know there's more, but that'll get us to our
    goal today.
- Type aliases are the exact same syntax as C++. `pub` up front to be consumed
  elsewhere; `type` instead of `alias`.
- `structs` can be value initialized just like C++. Attributes must be `pub` in
  order to do that though.
- Creating structs or calling functions from other modules is just like using
  something from a different namespace in C++. Rust style is shortened snake
  case for everything except types I think.
- Use `&` before <type> or `mut <type>` to signify a reference to a type. Seems
  straightforward, but I don't know if it's overloaded to also mean the address
  of a pointer like in C++. Important as Rust's borrow checker won't take
  ownership from the original caller.
- Use `impl` blocks to define methods for structs (and potentially other
  types?). Must use `&self` as first argument to methods or else they're
  static. All calls to struct methods and variables must use `self.method()` or
  `self.var`.
- Traits are like interfaces. Not sure of the nuanced differences for now. Rust
  wants you to put `dyn` before trait parameters to functions.
- Rust warns if a call returns a Result and you don't handle it. If you have no
  intention of handling the Result, but also don't expect the call to fail you
  can use `expect()` to panic and crash the program with some sort of error
  message.

Section 4.1, 4.2
----------------
- Ok, so we might want to look at how to include files in a different manner now.
  I know System76 has some Rust repos on Github that are GPL3 (should work with
  my license) so let's just go look at some examples (and consult StackOverflow!).
  - For files not named main, just place them alongside main without the `mod`
    wrapping. In main (or, I guess, other files as well) put `mod <file_name>`.
  - Yeah...that didn't work. To the docs!
    - A crate is a binary or library.
    - A package is 1+ crates. Restricted to only one library per package.
    - `src/main.rs` or `src/lib.rs` means a binary or library crate with the same
      name as the package. Rust files in `src/bin` will create as many binary
      crates with as many names as the files.
    - Modules are "silos", scopes or namespaces within a crate. Everything is
      private by default. Children can see their parent context; not the other
      way around. Put `pub` before `mod` and `fn` to be seen outside module.
    - `use` is like creating a symbolic link. Somewhat like #include in C++. There
      are relative and absolute module paths. To use an absolute module path start
      the import with `crate::`.
- Now that I'm looking at this old code I can see I didn't actually use an array
  for Vec3. Fixed that.
- Also, the utility functions for vec3 are marked inline. Rust inlines through
  attributes. Will probably dig into them more for tests / docs.
- `const` functions in Rust are different from C++ const member functions. Actually
  like `constexpr`.
- Switched to a different PC to do work. Locking the toolchain to a specific version
  was a little frustrating, but the rust-toolchain file is set (for now).
- So to do "operator overloading" I basically need to implement traits for a struct.
  Doesn't seem too crazy.
- Ampersands signify references to types like C++. Really important as the borrow
  checker "unbinds" or moves ownership into functions if not passed by ref.
  - Speaking of the borrow checker...I got my first error related to "borrow of a
    moved value" in the unit_vector function. Guess it's time to learn.
    - Book presents ownership, borrowing and lifetimes as three parts of the
      ownership system (borrow checker?). Ownership is move by default; implement
      Copy trait if you want that. Unlike C++, after a move you cannot reference
      the variable again.
    - Borrowing is...just passing by reference? Use the ampersand at both the call
      site and the function declaration. Like variables in function, const unless
      `mut` is used. If so, you put `*` before variable name when modifying. Can
      only have one mutating reference at a time.
    - Lifetime just refers to how long data lives. It's mainly within scopes. Be
      careful with your references.
      - `'a` introduced here as "the lifetime a". "We need to ensure any reference
        to" a type "cannot outlive the reference to" a type "it contains." AKA you
        probably need this if you have a struct with a reference and you return that
        reference through a getter. This ensures whatever variable is bound to the
        reference goes out of scope before the original reference.
      - `'static` is a special lifetime that means it's valid for the entire life of
        the program.
- `as` signifies a cast. Coercions are harmless (as the docs put it) casts. Casts can
  be dangerous, so they use a keyword for a sign post.
- The vec3 class in C++ does no delete the copy constructor so we're going to implement
  the Copy trait.

Section 5.1, 5.2
----------------
- Unlike C++ you have to dereference references (with *)
- First time hitting an `if` block. Apparently you don't use parentheses for them.
- Somehow in the switching of environments (and maybe my brain getting a bit tired) I
  committed a few bugs. Rectified.

Section 6.1, 6.2, 6.3
---------------------
- sqrt is a function on the f64 type.
- Ok, hitting runtime polymorphism code (encountered a little bit before). Can use `dyn`
  with function arguments or use generics for static polymorphism (aka C++ templates).
  - `pub` before function declarations in traits is an error. Apparently either the
    whole trait is public or the whole trait is private.

A Brief Aside Regarding Tooling
-------------------------------
- The `rustup-toolchain` file was thrown into the repo when I switched to a Windows
  machine. Coming back to Linux that file did not work (beyond removing the obvious
  Windows platform only line). At this point I have read the rustup book and did not
  find any obvious problems. In fact, the problem appeared to be related to not having
  updated the rustup tool on Linux since summer. I imagine the tool did not know about
  the revision I pinned. Always keep your tools up to date!

Section 6.4, 6.5, 6.6, 6.7
--------------------------
- `if` `else` blocks return the last expression just like functions. I don't know why,
  but this is blowing my mind. Much nicer than ternary operators in my opinion.
- Finally hit a file name that's "two" words. Found the following link:
  https://rust-lang.github.io/api-guidelines/naming.html. Modules are snake case so
  that's what I'm going with.
- Oh man, `shared_ptr`. I really only have experience with `unique_ptr` so let's dive
  into this and see if there's a Rust equivalent.
  - We're single-threaded at the moment so let's go with `std::rc::Rc`.
- Iterating over a container in a for loop actually copies the individual objects
  unless you use a slice. That's definitely something that will trip me up in the
  future. At least the compiler warns you (but only if you don't implement the Copy
  trait?).
- Ok, up to this point I've somewhat avoided default constructors (partially out of
  ignorance). Naming and initializing all the fields of a type at instantiation is
  the only way to create an object in Rust. Source:
  https://doc.rust-lang.org/nightly/nomicon/constructors.html. "Default" constructors
  are static `new` functions for the type. Adding for types that had a default
  constructor in C++.
- No overloaded functions in Rust so no overloaded constructors.

Section 7.1, 7.2
----------------
- We've hit our first absolute need for crates in `rand`. Fortunately this crate is
  used in the early parts of the Rust book so it should be easy to add. This interface is
  a little different than the C version so we'll try to adapt correctly.
- Apparently if you want to not use variables you prefix them with an underscore. At
  least, that's what the compiler is telling me to do.

A Brief Aside For Resolutions
-----------------------------
- The raytracer is starting to take some time, but it's also getting tougher to appreciate
  the output at the lower resolution. I'm adding a switch to create a larger image.
- Two "new" Rust concepts: while loops and iterators
  - We're going to use peekable iterators. This lets us use a while loop to check for our
    end condition in the initial state as well as all following states. As we evaluate
    iterator arguments we'll peek at the next one to make sure it's a valid input before
    doing work.
    - Iterators return the Option type. I've briefly seen this pattern so it's not
      surprising, but I do need to readjust my thinking for it.
    - Also, the Result type is used as part of the parse call. This uses the Rust enum
      type which I know is different and probably usable. Also, according to the docs I
      read Result is for areas where there are expected errors.
    - As a design decision we'll change `image_width` to `u32` so the user can't enter a
      negative resolution. This shouldn't impact the code we've written so far in any
      meaningful way.

Section 8.1, 8.2, 8.3, 8.4, 8.5, 8.6
------------------------------------
- `loop` denotes an infinite loop (replacement for `while true`). Seems simple enough.

Section 9.1, 9.2, 9.3, 9.4, 9.5
-------------------------------
- In Section 9.2 the `hit_record` (`HitRecord` for us) struct is updated with a shared_ptr.
  This does not affect structs and classes in C++ because a shared_ptr has a default
  constructor that will initialize its internal pointer to null. Thus, it works for free
  (with this program implementation) in C++. We can't do that in Rust with `Rc` because the
  `Default` trait can't implement a dynamic trait (`Material`) and `Rc` has to be
  initialized with something.
  - Solved the problem by wrapping the `Rc` with an `Option` and using pattern matching in
    `main::ray_color`. I'm almost certain there's a better way to do this, but I'm learning!

Section 10.1, 10.2, 10.3, 10.4, 10.5
------------------------------------
- Changed `use std::rc` to `use std::rc::Rc`. Everything is verbose enough.
- I know the use of material_left_two is a lazy hack, but it's late and it works.

Section 11.1, 11.2
------------------
- Nothing new to add!

Section 12.1, 12.2
------------------
- Nothing new to add!